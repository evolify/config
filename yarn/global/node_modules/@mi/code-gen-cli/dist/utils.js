"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUsage = exports.gennerate = exports.createPromptProvider = exports.parseSchematicName = exports.getSchematics = exports.listSchematics = exports.installCommand = exports.useYarn = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const core_1 = require("@angular-devkit/core");
const node_1 = require("@angular-devkit/core/node");
const schematics_2 = require("@angular-devkit/schematics");
const tools_1 = require("@angular-devkit/schematics/tools");
const inquirer = require("inquirer");
const code_gen_utils_1 = require("@mi/code-gen-utils");
const shelljs_1 = require("shelljs");
const signale = require("signale");
exports.useYarn = (_a = process.env.npm_config_user_agent) === null || _a === void 0 ? void 0 : _a.includes("yarn");
const installCommand = (pkgName) => `${exports.useYarn ? 'npm i -g' : 'yarn global add'} ${pkgName} --registry http://registry.npm.pt.mi.com/`;
exports.installCommand = installCommand;
/**
 * 校验collection是否可用
 * @param collectionName collection名称
 */
function validateCollection(collectionName) {
    const engineHost = new tools_1.NodeModulesEngineHost();
    const engine = new schematics_1.SchematicEngine(engineHost);
    let collection;
    try {
        collection = engine.createCollection(collectionName);
    }
    catch (err) {
        const interactive = new signale.Signale({ interactive: true, scope: 'interactive' });
        if (err.message.includes("cannot be resolved")) {
            interactive.await("模板未安装，安装中");
            const child = shelljs_1.exec(exports.installCommand(collectionName), { silent: true });
            if (!child.stderr) {
                interactive.success("模板安装成功");
                collection = engine.createCollection(collectionName);
            }
            else {
                interactive.error("模板安装失败");
            }
        }
        else {
            interactive.error("获取schematics失败");
        }
    }
    return {
        engine,
        collection,
        ready: engine && collection
    };
}
function listSchematics(collectionName) {
    try {
        const engineHost = new tools_1.NodeModulesEngineHost();
        const engine = new schematics_1.SchematicEngine(engineHost);
        const collection = engine.createCollection(collectionName);
        return engine.listSchematicNames(collection);
    }
    catch (err) {
        if (err.message.includes("cannot be resolved")) {
            return undefined;
        }
        else {
            return [];
        }
    }
}
exports.listSchematics = listSchematics;
/**
 * 获取指定模板的schematics, 如果模板未安装，则先全局安装，再获取
 * @param collectionName 模板名称
 */
function getSchematics(collectionName) {
    const { engine, collection } = validateCollection(collectionName);
    return collection ? engine.listSchematicNames(collection) : [];
}
exports.getSchematics = getSchematics;
/**
 * 解析指定模板的collection和schematic
 * @param str The argument to parse.
 * @return {{collection: string, schematic: (string)}}
 */
function parseSchematicName(str, debug = false) {
    return __awaiter(this, void 0, void 0, function* () {
        let collection = "";
        let schematic = "";
        let ready = true;
        if (str === null || str === void 0 ? void 0 : str.includes(":")) {
            [collection, schematic] = str.split(':', 2);
        }
        else {
            collection = str || "";
        }
        const templates = yield code_gen_utils_1.getTemplates();
        // 按照约定，模板名称应该以 @mi/tmpl- 开头，所以这部分可以省略
        if (!collection.startsWith("@mi/tmpl-")) {
            collection = `@mi/tmpl-${collection}`;
        }
        if (!debug) {
            // 非debug模式下，先校验模板是否存在于模板库中
            collection = templates.find(t => t === collection) || '';
        }
        if (!collection) {
            const { collection: data } = yield inquirer.prompt([{
                    name: "collection",
                    type: "list",
                    message: "Collection不存在，请选择一个模板",
                    choices: templates
                }]);
            collection = data;
        }
        // 如果没有提供schematic，那么在获取schematics的时候，会校验collection，否则就需要校验一遍
        if (!schematic) {
            const schematics = getSchematics(collection);
            if (schematics.length) {
                const { schematic: data } = yield inquirer.prompt([{
                        name: "schematic",
                        type: "list",
                        message: "Schematic不存在，请选择",
                        choices: schematics
                    }]);
                schematic = data;
            }
        }
        else {
            if (!validateCollection(collection).ready) {
                signale.error("初始化collection失败");
                ready = false;
            }
        }
        return { collection, schematic, ready: ready && Boolean(collection && schematic) };
    });
}
exports.parseSchematicName = parseSchematicName;
function createPromptProvider() {
    return (definitions) => {
        const questions = definitions.map(definition => {
            const question = {
                name: definition.id,
                message: definition.message,
                default: definition.default,
            };
            const validator = definition.validator;
            if (validator) {
                question.validate = (input) => validator(input);
            }
            switch (definition.type) {
                case 'confirmation':
                    return Object.assign(Object.assign({}, question), { type: 'confirm' });
                case 'list':
                    return Object.assign(Object.assign({}, question), { type: !!definition.multiselect ? 'checkbox' : 'list', choices: definition.items && definition.items.map(item => {
                            if (typeof item == 'string') {
                                return item;
                            }
                            else {
                                return {
                                    name: item.label,
                                    value: item.value,
                                };
                            }
                        }) });
                default:
                    return Object.assign(Object.assign({}, question), { type: definition.type });
            }
        });
        return inquirer.prompt(questions);
    };
}
exports.createPromptProvider = createPromptProvider;
function gennerate(collection, schematic, argv, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const isLocalCollection = collection.startsWith('.') || collection.startsWith('/');
        /** Gather the arguments for later use. */
        const debug = argv.debug === null ? isLocalCollection : argv.debug;
        const dryRun = argv['dry-run'] === null ? debug : argv['dry-run'];
        const force = argv['force'];
        const allowPrivate = argv['allow-private'];
        /** Create a Virtual FS Host scoped to where the process is being run. **/
        const fsHost = new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), core_1.normalize(process.cwd()));
        const registry = new core_1.schema.CoreSchemaRegistry(schematics_2.formats.standardFormats);
        /** Create the workflow that will be executed with this run. */
        const workflow = new tools_1.NodeWorkflow(fsHost, {
            force,
            dryRun,
            registry,
            resolvePaths: [process.cwd(), __dirname],
        });
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        workflow.engineHost.registerOptionsTransform(tools_1.validateOptionsWithSchema(registry));
        // Indicate to the user when nothing has been done. This is automatically set to off when there's
        // a new DryRunEvent.
        let nothingDone = true;
        // Logging queue that receives all the messages to show the users. This only get shown when no
        // errors happened.
        let loggingQueue = [];
        let error = false;
        /**
         * Logs out dry run events.
         *
         * All events will always be executed here, in order of discovery. That means that an error would
         * be shown along other events when it happens. Since errors in workflows will stop the Observable
         * from completing successfully, we record any events other than errors, then on completion we
         * show them.
         *
         * This is a simple way to only show errors when an error occur.
         */
        workflow.reporter.subscribe((event) => {
            nothingDone = false;
            // Strip leading slash to prevent confusion.
            const eventPath = event.path.startsWith('/') ? event.path.substr(1) : event.path;
            switch (event.kind) {
                case 'error':
                    error = true;
                    const desc = event.description == 'alreadyExist' ? 'already exists' : 'does not exist';
                    logger.error(`ERROR! ${eventPath} ${desc}.`);
                    break;
                case 'update':
                    loggingQueue.push(core_1.tags.oneLine `
        ${core_1.terminal.white('UPDATE')} ${eventPath} (${event.content.length} bytes)
      `);
                    break;
                case 'create':
                    loggingQueue.push(core_1.tags.oneLine `
        ${core_1.terminal.green('CREATE')} ${eventPath} (${event.content.length} bytes)
      `);
                    break;
                case 'delete':
                    loggingQueue.push(`${core_1.terminal.yellow('DELETE')} ${eventPath}`);
                    break;
                case 'rename':
                    const eventToPath = event.to.startsWith('/') ? event.to.substr(1) : event.to;
                    loggingQueue.push(`${core_1.terminal.blue('RENAME')} ${eventPath} => ${eventToPath}`);
                    break;
            }
        });
        /**
         * Listen to lifecycle events of the workflow to flush the logs between each phases.
         */
        workflow.lifeCycle.subscribe(event => {
            if (event.kind == 'workflow-end' || event.kind == 'post-tasks-start') {
                if (!error) {
                    // Flush the log queue and clean the error state.
                    loggingQueue.forEach(log => logger.info(log));
                }
                loggingQueue = [];
                error = false;
            }
        });
        /**
         * Remove every options from argv that we support in schematics itself.
         */
        const parsedArgs = Object.assign({}, argv);
        delete parsedArgs['--'];
        for (const key of booleanArgs) {
            delete parsedArgs[key];
        }
        // Pass the rest of the arguments as the smart default "argv". Then delete it.
        workflow.registry.addSmartDefaultProvider('argv', (schema) => {
            if ('index' in schema) {
                return argv._[Number(schema['index'])];
            }
            else {
                return argv._;
            }
        });
        delete parsedArgs._;
        // Add prompts.
        workflow.registry.usePromptProvider(createPromptProvider());
        /**
         *  Execute the workflow, which will report the dry run events, run the tasks, and complete
         *  after all is done.
         *
         *  The Observable returned will properly cancel the workflow if unsubscribed, error out if ANY
         *  step of the workflow failed (sink or task), with details included, and will only complete
         *  when everything is done.
         */
        try {
            yield workflow.execute({
                collection: collection,
                schematic: schematic,
                options: parsedArgs,
                allowPrivate: allowPrivate,
                debug: debug,
                logger: logger,
            })
                .toPromise();
            if (nothingDone) {
                logger.info('Nothing to be done.');
            }
            return 0;
        }
        catch (err) {
            if (err instanceof schematics_2.UnsuccessfulWorkflowExecution) {
                // "See above" because we already printed the error.
                logger.fatal('The Schematic workflow failed. See above.');
            }
            else if (debug) {
                logger.fatal('An error occured:\n' + err.stack);
            }
            else {
                logger.fatal(err.stack || err.message);
            }
            return 1;
        }
    });
}
exports.gennerate = gennerate;
/**
* Get usage of the CLI tool.
*/
function getUsage() {
    return core_1.tags.stripIndent `
  gen [CollectionName:]SchematicName [options, ...]

  By default, if the collection name is not specified, use the internal collection provided
  by the Schematics CLI.

  Options:
      --debug             Debug mode. This is true by default if the collection is a relative
                          path (in that case, turn off with --debug=false).

      --allow-private     Allow private schematics to be run from the command line. Default to
                          false.

      --dry-run           Do not output anything, but instead just show what actions would be
                          performed. Default to true if debug is also true.

      --force             Force overwriting files that would otherwise be an error.

      --list-schematics   List all schematics from the collection, by name. A collection name
                          should be suffixed by a colon. Example: '@schematics/schematics:'.

      --verbose           Show more information.

      --help              Show this message.

  Any additional option is passed to the Schematics depending on
  `;
}
exports.getUsage = getUsage;
/** Parse the command line. */
const booleanArgs = [
    'allowPrivate',
    'allow-private',
    'debug',
    'dry-run',
    'dryRun',
    'force',
    'help',
    'list-schematics',
    'listSchematics',
    'verbose',
];
//# sourceMappingURL=utils.js.map